<!DOCTYPE html>
<html>
    <head>
        <title>Coding First Aid Kit</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="author" content="Lisa">
        <meta name="description" content="Console-based ascii art comic.">

        <style>
            :root {
                --bgCol: #333;
                --fCol: #fff;
                --errCol: yellow;
            }
            html, body {
                width: 100vw;
                margin: auto;;
                line-height: 1.5em;
                background-color: var(--bgCol);
                color: var(--fCol);
            }
            body {
                padding: 1em;
            }
            label, summary {
                color: var(--errCol);
            }
            * {
                box-sizing: border-box;
                font-family: "Courier New", "Courier New", monospace, monospace;
            }
            h1 {
                text-align: center;
            }
            section {
                margin-bottom: 2em;
            }
            textarea {
                width: 100%;
                resize: vertical;
                height: 5em;
                display: none;
                background-color: var(--bgCol);
                color: var(--fCol);
                line-height: 1em;
                text-align: left;
            }
            #output {
                height: 35em;
            }
        </style>
    </head>
    <body>
        <h1>Coding First Aid Kit</h1>
        <details>
            <summary>Info</summary>
            <p>A first aid kit for coding presented by Stu, the rabbit.</p>
        </details>
        <p>
            <label for='chp'>Chapter: </label>
            <select id='chp'>
                <option selected>Choose a story.</option>
            </select>
            <br>
            <label for='onpage'>On-page: </label><input type="checkbox" id='onpage' checked>
        </p>
        <section id='input'>
            <label>LouScript:</label><br>


            <textarea class='ljson' data-title='Coding First Aid' readonly disabled>{"META":{"TITLE":"Coding First Aid Kit","AUTHOR":"Lou J. Son","VERSION":"2023-05-23","SUMMARY":"Stu packs a coding first aid kit and puts in it..."},"SCENE":{"#cover":[["TEXTBOX","Coding First Aid Kit"],["ASCII","            /\\ /\\           \n            \\/_\\/           \n            (o.O)           \n          tt/ \" \\           \n            ()~()           ",{"tt":"🧰"}],["THOUGHT",[["Stu","From Stu"]]]],"#00":[["TEXTBOX","This is Stu. Stu packs a coding first aid kit and puts in it..."],["ASCII","            /\\ /\\           \n            \\/_\\/           \n            (o.O)           \n          tt/ \" \\           \n            ()~()           ",{"tt":"🧰"}]],"#01":[["TEXTBOX","...a letter,"],["SPEECH",[["Stu","Read the error message again and double check your code!"]]],["ASCII","   ------          /\\ /\\    \n  | Ò  Ò |         \\/_\\/    \n  |  __  |         (o.O)    \n   ------        tt/ \" \\    \n    _||_           ()~()    ",{"tt":"💌"}]],"#02":[["TEXTBOX","...the same letter again,"],["SPEECH",[["Stu","Repeat."]]],["ASCII","   ------          /\\ /\\    \n  | Ò  Ò |         \\/_\\/    \n  |  __  |         (o.O)    \n   ------        tt/ \" \\    \n    _||_           ()~()    ",{"tt":"💌"}]],"#03":[["TEXTBOX","...a magnifying glass,"],["SPEECH",[["Stu","Duck, duck if others have encountered similar issues!"]]],["ASCII","                   /\\ /\\    \n                   \\/_\\/    \n                   (o.O)    \n    (o)< (o)<    tt/ \" \\    \n   \\(_) \\(_)       ()~()    ",{"tt":"🔍"}]],"#04":[["TEXTBOX","...a folder,"],["SPEECH",[["Stu","Look up examples and docs -- compare to your own code."]]],["ASCII","      ____         /\\ /\\    \n     /    \\        \\/_\\/    \n    / THE  \\       (o.O)    \n    \\ DOCS /     tt/ \" \\    \n     \\____/        ()~()    ",{"tt":"📁"}]],"#05":[["TEXTBOX","...a cup of tea,"],["SPEECH",[["Stu","Have a break."]]],["ASCII","                   /\\ /\\    \n    abbcc          \\/_\\/    \n    ______         (o.O)    \n      ||         tt/ \" \\    \n      ||           ()~()    ",{"tt":"🥤","a":"☕","bb":"🍵","cc":"🥕"}]],"#06":[["TEXTBOX","...a light bulb,"],["SPEECH",[["Stu","Challenge your concept of how you think it should work."]]],["ASCII","                   /\\ /\\    \n                   \\/_\\/    \n                   (o.O)    \n                 tt/ \" \\    \n                   ()~()    ",{"tt":"💡"}]],"#07":[["TEXTBOX","...a map,"],["SPEECH",[["Stu","Try a different approach. There is often more than one way."]]],["ASCII","    ______         /\\ /\\    \n   /      |        \\/_\\/    \n  / OTHER |        (o.O)    \n  \\  WAYS |     ttt/ \" \\    \n   \\______|        ()~()    ",{"ttt":"🗺️"}]],"#08":[["TEXTBOX","...a puzzle piece,"],["SPEECH",[["Stu","Disassemble and reassemble!"]]],["ASCII","                   /\\ /\\    \n                   \\/_\\/    \n    tt tt          (o.O)    \n    tt tt        tt/ \" \\    \n    tt tt          ()~()    ",{"tt":"🧩"}]],"#09":[["TEXTBOX","...an umbrella,"],["SPEECH",[["Stu","Pour your heart out to me. But let me get an umbrella first."]]],["ASCII","                   /\\ /\\    \n                   \\/_\\/    \n                   (o.O)    \n                 tt/ \" \\    \n                   ()~()    ",{"tt":"☂️"}]],"#10":[["TEXTBOX","...a teddy bear,"],["SPEECH",[["Stu","Go to sleep. Try again tomorrow."]]],["ASCII","                   /\\ /\\    \n                   \\/_\\/    \n  |                (o.O)    \n  |_______|      tt/ \" \\    \n  |       |        ()~()    ",{"tt":"🧸"}]],"#11":[["TEXTBOX","...and finally:"],["SPEECH",[["Stu","Let someone else look at your code."]]],["ASCII","   ------    (8)     /\\ /\\  \n  | ^  ^ |  (888)    \\/_\\/  \n  |  __  | 8(o_o)8   (o.O)  \n   ------    / \\     / \" \\  \n    _||_     | |     ()~()  "]]}}</textarea>
            
        </section>
        <section>
            <label>Console:</label><br>
            <textarea readonly id='output'></textarea>
        </section>

        <script>

            function chunkText(text, maxlength) {
                /* Split string into chunk of max. length
                */
                const chunkRegex = new RegExp('.{1,' + maxlength + '}(?:\\s|$)', 'g');
                text = text.match(chunkRegex);
                text = text.map(s => s.trim());
                return text;
            }
            function hangingIndent(textArr, pre='> ') {
                const preLen = pre.length;
                textArr.forEach((val, idx) => {
                    if (idx == 0) textArr[idx] = `${pre}${val}`;
                    else textArr[idx] = `${' '.repeat(preLen)}${val}`;
                });
                return textArr;
            }
            function alignStrings(textArr, lineWidth) {
                textArr.forEach((val, idx) => {
                    if (val.length < lineWidth) textArr[idx] = `${val}${' '.repeat(lineWidth - val.length)}`;
                })
                return textArr;
            }

            function prepareScene(scene, defaultWidth=28) {

                // find max. col ascii image to determine scene width
                let w = [];
                for (const section of scene) {
                    if (section[0] == 'ASCII') {
                        const nrows = section[1].split('\n').length;
                        const ncols = (section[1].length - nrows + 1) / nrows;
                        w.push(ncols);
                    }
                }
                w = w.length > 0 ? Math.max(...w) : defaultWidth;
                const emptySpace = ' '.repeat(w);

                // create section arrays
                const sceneArr = [];
                for (let sidx=0; sidx < scene.length; sidx++) {
                    const [sType, sContent, sOther] = scene[sidx];
                    let names, n, indent = 4, isNotFirst = false;
                    switch(sType) {
                        case 'TEXTBOX':
                            const chunks = chunkText(sContent, w);
                            sceneArr.push([sType, alignStrings(chunks, w)]);
                            break;
                        case 'ASCII':
                            //console.log(sContent, sOther)
                            const nrows = sContent.split('\n').length;
                            const ncols = (sContent.length - nrows + 1) / nrows;
                            let ascii = sContent.split('\n');
                            if (ncols != w)  {
                                ascii = alignStrings(chunkText(ascii, w), w);
                            }
                            if (typeof sOther !== 'undefined') {
                                for (const key in sOther) {
                                    ascii.forEach((val, idx) => {
                                        ascii[idx] = val.replaceAll(key, sOther[key]);
                                    });
                                }
                            }
                            if (sidx != 0) ascii.unshift(emptySpace);
                            sceneArr.push([sType, ascii]);
                            break;
                        case 'SPEECH':
                            // determine number of speakers
                            names = sContent.map(val => val[0]);
                            n = new Set(names).size;
                            for (const sp of sContent) {
                                let [name, text] = sp;
                                const nameIdx = names.indexOf(name);
                                const ind = (w-n*indent) < 7 ? 7: (w-n*indent);
                                text = chunkText(text, ind);
                                text = hangingIndent(text, `${' '.repeat(nameIdx*indent)}> `);
                                text = alignStrings(text, w);
                                if (isNotFirst || (sidx>=1 && scene.length > 1)) text.unshift(emptySpace);
                                sceneArr.push([sType, text]);
                                isNotFirst = true;
                            }
                            break;
                        case 'THOUGHT':
                            // determine number of thinkers
                            names = sContent.map(val => val[0]);
                            n = new Set(names).size;
                            for (const sp of sContent) {
                                let [name, text] = sp;
                                const nameIdx = names.indexOf(name);
                                const ind = (w-n*indent) < 7 ? 7: (w-n*indent);
                                text = chunkText(text, ind);
                                text = hangingIndent(text, `${' '.repeat(nameIdx*indent)}* `);
                                text = alignStrings(text, w);
                                if (isNotFirst || (sidx>=1 && scene.length > 1)) text.unshift(emptySpace);
                                sceneArr.push([sType, text]);
                                isNotFirst = true;
                            }
                            break;
                    }
                }
                return {"width": w, "section": sceneArr};
            }

            function makePanel(scene) {
                // preprare scene
                const sceneObj = prepareScene(scene);
                const w = sceneObj.width;
                const section = sceneObj.section;
                

                // assemble panel
                let panel = '';
                for (let idx = 0; idx < section.length; idx++) {
                    let [sType, sContent] = section[idx];
                    sContent.forEach((val, idx) => {
                        sContent[idx] = `| ${val} |`;
                    });
                    let topBorder = '', bottomBorder = '';

                    // top border?
                    if (idx == 0 || sType == 'TEXTBOX') {
                        // top-border
                        topBorder = '_'.repeat(w+4) + '\n' + `|${' '.repeat(w+2)}|`;
                        panel += topBorder + '\n';
                    }
                    // content
                    panel += sContent.join('\n');
                    // bottom border?
                    if (idx == section.length-1 || sType == 'TEXTBOX') {
                        bottomBorder = '\n'+`|${'_'.repeat(w+2)}|`;
                        panel += bottomBorder ;
                    }
                    panel += '\n';
                }
                return panel;
            }

            function main() {
                const $ = document;
                const chpSelect = $.getElementById('chp');
                const ljson = $.getElementsByClassName('ljson');
                const output = $.getElementById('output');
                const onpage = $.getElementById('onpage');
                onpage.checked = true;
                window.rev = false;


                // find stories
                const numLen = (ljson.length - 1).toString().length;
                for (let idx = 0; idx < ljson.length; idx++) {
                    const opt = $.createElement('option');
                    opt.textContent = `${idx.toString().padStart(numLen, '0')}) ` + (ljson[idx]).dataset.title;
                    opt.value = (ljson[idx]).dataset.title;
                    chpSelect.appendChild(opt);
                }

                // select story
                chpSelect.addEventListener('change', function(ev) {
                    let title = ev.target.value; //console.log(title)
                    output.value = ''; //console.log(ljson.length)
                    
                    for (const story of ljson) {
                        if (story.dataset.title == title) {
                            story.style.display = 'block';
                            output.style.display = 'block'; //console.log(story.value);
                            let scenes;
                            scenes = JSON.parse(story.value).SCENE;
                            
                            let panels = [];
                            for (const s in scenes) {
                                let scene = scenes[s];
                                if (window.rev) {
                                    panels.unshift(makePanel(scene)); // reverse order
                                }
                                else {
                                    panels.push(makePanel(scene));
                                }
                            }
                            for (const p of panels) {
                                if (!onpage.checked) {
                                    console.log(p);
                                }
                                else {
                                    output.value += p + "\n";
                                }
                            }
                            if (onpage.checked) {
                                if (window.rev) {
                                    output.scrollTop = output.scrollHeight;
                                    window.scrollTo(0, $.body.scrollHeight);
                                }
                                else {
                                    output.scrollTop = 0;
                                    window.scrollTo(0, 0);
                                }
                            }
                            if (!onpage.checked) output.value = 'Console';
                        }
                        else {
                            story.style.display = 'none';
                        }
                    }
                });

            }

            window.onload = main();
        </script>
    </body>
</html>